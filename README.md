# gof

Javaのデザインパターンを学ぶために、GoFの２３このデザインパターンを勉強します。
勉強に当たり以下のURLのサイトを参考にさせていただきます。

<http://www.techscore.com/tech/DesignPattern/index.html/>

* Itelator
    * 構造化されたオブジェクトに順次アクセスさせる場合に適用させることで、変更範囲が少なくなるパターン
* Adapter
    * インターフェースに互換性の無いクラス同士を組み合わせるのに利用できるパターン
* TemplateMethod
    * スーパークラスでアルゴリズムのメソッドを定義して、サブクラスで具体的内容を実装するパターン
* FactoryMethod
    * TemplateMethodでインスタンスの生成をサブクラスに任せることで、柔軟な実装が可能となるパターン
* ProtoType
    * 複製メソッドを用意したパターン
* Builder
    * Directorで表現形式（手順書的なもの）、Builderで作成過程（どのように処理するか）を決定することで、同じ要求を異なる形式で表現できるパターン
* AbstractFactory
    * 特定の組み合わせが要求されるオブジェクト群を誤りなく生成できる。生成されるオブジェクトの実装を隠蔽することができる
* Bridge
    * 機能を拡張するための階層と実装を拡張するための階層を独立させることができる
* Strategy
    * if文などの分岐が生じるような処理を意識して別クラス（戦略クラス）を作成させることで、戦略部分の処理の切り替えや追加が用意になる。
* Composite
    * tree構造の範囲で再帰的な取扱が用意になる
* Decorator
    * オブジェクトに対してクラスの拡張よりも柔軟に機能追加ができる。（既存のコードに影響なく機能追加できる）
* Visitor
    * 処理を訪問者「visitor」クラスにまとめることどえ、処理の追加を容易にするクラス。Acceptorクラスではacceptの処理を追加する必要がある。
* ChainResponsiblity
    * 責任者まで決裁を回すことでいずれか処理を決定する権限者にたどり着く。処理速度に問題が発生する可能性あり
* Facade
    * 多くのロジックを簡素化して、一つのシンプルな関数呼び出しにまとめること
* Mediator
    * 複数のオブジェクト間の調整を行う。例えば複雑な条件を満たす必要のある判定処理などのインターフェースに利用できる
* Observer
    * 観察される側（Subject）の状態が変化した際に、観察側（Observer）に通知されるパターン。MVCもでるのMVの関係性。
    [デザインパターン「Observer」](https://qiita.com/shoheiyokoyama/items/d4b844ed29f84a80795b#observer)を参考にしました。
* Memento
    * インスタンスの状態のスナップショットを保存して、あとからその状態を復元できる状態にする
* State
    * 状態をクラスとして表現するパターン。if文の制御が少なくなる。
* Flyweight
    * 不要なインスタンスの作成を減らし、軽量化すべきインスタンスの生成、管理を行う
* Proxy
    * 代理人ができる限り処理を行うことで、無駄な初期化などを防ぐ。また、代理人を変更することで処理を自由に変更することができる